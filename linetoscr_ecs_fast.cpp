/*
* UAE - The portable Amiga emulator.
*
* This file was generated by genlinetoscr. Don't edit.
*/

static void lts_ecs_n_ilores_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_dpf_ilores_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ehb_ilores_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ham_ilores_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_kehb_ilores_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_n_ihires_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_dpf_ihires_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ehb_ihires_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ham_ihires_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_kehb_ihires_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_n_ishres_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_dpf_ishres_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ehb_ishres_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ham_ishres_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_kehb_ishres_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_n_ilores_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_dpf_ilores_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
				c = *cp;
				cp += cpadd;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ehb_ilores_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
				c = *cp;
				cp += cpadd;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ham_ilores_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
				c = *cp;
				cp += cpadd;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_kehb_ilores_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_n_ihires_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_dpf_ihires_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ehb_ihires_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ham_ihires_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_kehb_ihires_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_n_ishres_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_dpf_ishres_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ehb_ishres_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ham_ishres_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_kehb_ishres_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_n_ilores_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
				c = *cp;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
				c = *cp;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_dpf_ilores_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
				c = *cp;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
				c = *cp;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
				c = *cp;
				cp += cpadd;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ehb_ilores_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
				c = *cp;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
				c = *cp;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
				c = *cp;
				cp += cpadd;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ham_ilores_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
				c = *cp;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
				c = *cp;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
				c = *cp;
				cp += cpadd;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_kehb_ilores_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
				c = *cp;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
				c = *cp;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_n_ihires_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_dpf_ihires_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
				c = *cp;
				cp += cpadd;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ehb_ihires_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
				c = *cp;
				cp += cpadd;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ham_ihires_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
				c = *cp;
				cp += cpadd;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_kehb_ihires_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_n_ishres_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_dpf_ishres_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ehb_ishres_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ham_ishres_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_kehb_ishres_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_n_ilores_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_dpf_ilores_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ehb_ilores_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ham_ilores_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_kehb_ilores_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_n_ihires_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_dpf_ihires_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ehb_ihires_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ham_ihires_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_kehb_ihires_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_n_ishres_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_dpf_ishres_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ehb_ishres_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ham_ishres_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_kehb_ishres_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_n_ilores_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
				*buf2++ = col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_dpf_ilores_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
				*buf2++ = col;
				c = *cp;
				cp += cpadd;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ehb_ilores_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
				*buf2++ = col;
				c = *cp;
				cp += cpadd;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ham_ilores_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
				*buf2++ = col;
				c = *cp;
				cp += cpadd;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_kehb_ilores_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
				*buf2++ = col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_n_ihires_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_dpf_ihires_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ehb_ihires_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ham_ihires_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_kehb_ihires_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_n_ishres_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_dpf_ishres_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ehb_ishres_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ham_ishres_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_kehb_ishres_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_n_ilores_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
				*buf2++ = bgcolor;
				*buf2++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
				*buf2++ = col;
				c = *cp;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
				*buf2++ = col;
				c = *cp;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
				*buf2++ = col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_dpf_ilores_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
				*buf2++ = bgcolor;
				*buf2++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
				*buf2++ = col;
				c = *cp;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
				*buf2++ = col;
				c = *cp;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
				*buf2++ = col;
				c = *cp;
				cp += cpadd;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ehb_ilores_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
				*buf2++ = bgcolor;
				*buf2++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
				*buf2++ = col;
				c = *cp;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
				*buf2++ = col;
				c = *cp;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
				*buf2++ = col;
				c = *cp;
				cp += cpadd;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ham_ilores_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
				*buf2++ = bgcolor;
				*buf2++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
				*buf2++ = col;
				c = *cp;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
				*buf2++ = col;
				c = *cp;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
				*buf2++ = col;
				c = *cp;
				cp += cpadd;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_kehb_ilores_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
				*buf2++ = bgcolor;
				*buf2++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
				*buf2++ = col;
				c = *cp;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
				*buf2++ = col;
				c = *cp;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
				*buf2++ = col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_n_ihires_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
				*buf2++ = col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_dpf_ihires_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
				*buf2++ = col;
				c = *cp;
				cp += cpadd;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ehb_ihires_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
				*buf2++ = col;
				c = *cp;
				cp += cpadd;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ham_ihires_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
				*buf2++ = col;
				c = *cp;
				cp += cpadd;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_kehb_ihires_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
				*buf2++ = col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_n_ishres_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c]];
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_dpf_ishres_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				{
					uae_u8 dpval = dpf_lookup[c];
					col = xcolors[colors_ocs[dpval]];
				}
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ehb_ishres_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				c &= bplehb_mask;
				if (c <= 31) {
					col = xcolors[colors_ocs[c]];
				} else {
					col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
				}
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_ham_ishres_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = decode_ham_pixel_fast(c, colors_ocs);
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static void lts_ecs_kehb_ishres_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, uae_u8 bxor, void *colors)
{
	uae_u16 *colors_ocs = (uae_u16*)colors;
	int cnt = draw_start;
	while (cnt < draw_end) {
		bool bpl = false;
		if (cnt >= hbstrt_offset) {
			break;
		}
		if (cnt >= draw_startoffset) {
			if (cnt < hbstop_offset) {
				buf1 += bufadd;
				buf2 += bufadd;
			} else if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
				*buf1++ = bgcolor;
				*buf2++ = bgcolor;
			}
			if (cnt >= bpl1dat_trigger_offset && cnt >= hstrt_offset && cnt < hstop_offset) {
				bpl = true;
				uae_u8 c;
				uae_u32 col;
				c = *cp;
				cp += cpadd;
				col = xcolors[colors_ocs[c & 31]];
				*buf1++ = col;
				*buf2++ = col;
			}
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpadd;
		}
		cnt += bufadd;
	}
}
static LINETOSRC_FUNCF linetoscr_ecs_fast_funcs[] = {
	lts_ecs_n_ilores_dlores_b1,
	lts_ecs_dpf_ilores_dlores_b1,
	lts_ecs_ehb_ilores_dlores_b1,
	lts_ecs_ham_ilores_dlores_b1,
	lts_ecs_kehb_ilores_dlores_b1,
	lts_ecs_n_ihires_dlores_b1,
	lts_ecs_dpf_ihires_dlores_b1,
	lts_ecs_ehb_ihires_dlores_b1,
	lts_ecs_ham_ihires_dlores_b1,
	lts_ecs_kehb_ihires_dlores_b1,
	lts_ecs_n_ishres_dlores_b1,
	lts_ecs_dpf_ishres_dlores_b1,
	lts_ecs_ehb_ishres_dlores_b1,
	lts_ecs_ham_ishres_dlores_b1,
	lts_ecs_kehb_ishres_dlores_b1,
	lts_ecs_n_ilores_dhires_b1,
	lts_ecs_dpf_ilores_dhires_b1,
	lts_ecs_ehb_ilores_dhires_b1,
	lts_ecs_ham_ilores_dhires_b1,
	lts_ecs_kehb_ilores_dhires_b1,
	lts_ecs_n_ihires_dhires_b1,
	lts_ecs_dpf_ihires_dhires_b1,
	lts_ecs_ehb_ihires_dhires_b1,
	lts_ecs_ham_ihires_dhires_b1,
	lts_ecs_kehb_ihires_dhires_b1,
	lts_ecs_n_ishres_dhires_b1,
	lts_ecs_dpf_ishres_dhires_b1,
	lts_ecs_ehb_ishres_dhires_b1,
	lts_ecs_ham_ishres_dhires_b1,
	lts_ecs_kehb_ishres_dhires_b1,
	lts_ecs_n_ilores_dshres_b1,
	lts_ecs_dpf_ilores_dshres_b1,
	lts_ecs_ehb_ilores_dshres_b1,
	lts_ecs_ham_ilores_dshres_b1,
	lts_ecs_kehb_ilores_dshres_b1,
	lts_ecs_n_ihires_dshres_b1,
	lts_ecs_dpf_ihires_dshres_b1,
	lts_ecs_ehb_ihires_dshres_b1,
	lts_ecs_ham_ihires_dshres_b1,
	lts_ecs_kehb_ihires_dshres_b1,
	lts_ecs_n_ishres_dshres_b1,
	lts_ecs_dpf_ishres_dshres_b1,
	lts_ecs_ehb_ishres_dshres_b1,
	lts_ecs_ham_ishres_dshres_b1,
	lts_ecs_kehb_ishres_dshres_b1,
	lts_ecs_n_ilores_dlores_b2,
	lts_ecs_dpf_ilores_dlores_b2,
	lts_ecs_ehb_ilores_dlores_b2,
	lts_ecs_ham_ilores_dlores_b2,
	lts_ecs_kehb_ilores_dlores_b2,
	lts_ecs_n_ihires_dlores_b2,
	lts_ecs_dpf_ihires_dlores_b2,
	lts_ecs_ehb_ihires_dlores_b2,
	lts_ecs_ham_ihires_dlores_b2,
	lts_ecs_kehb_ihires_dlores_b2,
	lts_ecs_n_ishres_dlores_b2,
	lts_ecs_dpf_ishres_dlores_b2,
	lts_ecs_ehb_ishres_dlores_b2,
	lts_ecs_ham_ishres_dlores_b2,
	lts_ecs_kehb_ishres_dlores_b2,
	lts_ecs_n_ilores_dhires_b2,
	lts_ecs_dpf_ilores_dhires_b2,
	lts_ecs_ehb_ilores_dhires_b2,
	lts_ecs_ham_ilores_dhires_b2,
	lts_ecs_kehb_ilores_dhires_b2,
	lts_ecs_n_ihires_dhires_b2,
	lts_ecs_dpf_ihires_dhires_b2,
	lts_ecs_ehb_ihires_dhires_b2,
	lts_ecs_ham_ihires_dhires_b2,
	lts_ecs_kehb_ihires_dhires_b2,
	lts_ecs_n_ishres_dhires_b2,
	lts_ecs_dpf_ishres_dhires_b2,
	lts_ecs_ehb_ishres_dhires_b2,
	lts_ecs_ham_ishres_dhires_b2,
	lts_ecs_kehb_ishres_dhires_b2,
	lts_ecs_n_ilores_dshres_b2,
	lts_ecs_dpf_ilores_dshres_b2,
	lts_ecs_ehb_ilores_dshres_b2,
	lts_ecs_ham_ilores_dshres_b2,
	lts_ecs_kehb_ilores_dshres_b2,
	lts_ecs_n_ihires_dshres_b2,
	lts_ecs_dpf_ihires_dshres_b2,
	lts_ecs_ehb_ihires_dshres_b2,
	lts_ecs_ham_ihires_dshres_b2,
	lts_ecs_kehb_ihires_dshres_b2,
	lts_ecs_n_ishres_dshres_b2,
	lts_ecs_dpf_ishres_dshres_b2,
	lts_ecs_ehb_ishres_dshres_b2,
	lts_ecs_ham_ishres_dshres_b2,
	lts_ecs_kehb_ishres_dshres_b2,
	NULL
};
